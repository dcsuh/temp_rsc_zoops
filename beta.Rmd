---
title: "beta"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message = F}
library(here)
source(here("base","src.R"))
```

# Questions

1. We measure beta at the scale of each treatment and we need beta to optimize our model. Does this mean our sample size is now the number of treatments (i.e., 9)?

2. Or can we estimate Beta now using foraging rate? But how would we optimize per-spore susceptibility?




We'll grab our estimates for Beta to use for our optimizer and we'll use the best fitting model to determine foraging rate at each temperature.
```{r}
beta_summ <- readRDS(here("processed_data", "beta_summary.rds"))
beta_summ %<>% filter(temp %in% const_temp) %>% filter(species == "D") %>% mutate(temp = as.numeric(temp))

aic_f <- readRDS(here("mle", "aic_table.rds"))
aic_f
f_coefs <- coef(readRDS(here("mle", "m7c_f_fit.rds")))
f_coefs

z <- 200 #200 spores/mL exposure and exposed for 24 hours
exp_time <- 1 #1 day
vol <- 15 #mL
ref_t <- 15 #degrees C
```


We can now calculate the effective foraging rate for all of our treatments using these parameter values and this equation

$$

observed\; f = \frac{fe^{T_{A}(1/T_{R}-1/T)}}{1 + fe^{T_{A}(1/T_{R}-1/T)}hR}\\

T_{A} = {T_{A}}'e^{{\rho}R}\\

h = h'e^{{\omega}T}\\

$$

This formulation assumes the coefficients from model 7c (full interaction exp-exp)
```{r}
get_f <- function(temp, resource){
  ref_t <- 15
  f <- as.numeric(f_coefs[1])
  arr_prime <- as.numeric(f_coefs[2])
  h_prime <- as.numeric(f_coefs[3])
  p <- as.numeric(f_coefs[4])
  w <- as.numeric(f_coefs[5])
    arr <- arr_prime*exp(p*resource)
    h <- h_prime*exp(w*temp)
    ((f*exp(arr*(1/ref_t - 1/temp)))/(1+f*exp(arr*(1/ref_t - 1/temp))*h*resource))
}
```

```{r}
beta_summ %<>% mutate(f = get_f(beta_summ$temp, beta_summ$resource))
```


We can use foraging rate to help us estimate beta and per-spore susceptibility. We now have estimates for foraging rate for all treatments and we can estimate beta using infection data. 

$$
\beta Z S = f u Z S \\
\beta  = f u 
$$

Beta is the rate at which individuals become infected which depends on the foraging rate, the concentration of spores, and the probability that an individual becomes infected when encountering a spore, i.e., u.

$$
u = \frac{f}{\beta}
$$
So rearranging this expression we can see that u is equivalent to the encounter rate divided by the transmission rate. 


We want to incorporate the effects of temperature and resource conditions on this as well. We can do this by getting an estimate for Beta for each treatment and using that as the objective function for our optimizer. In other words, which value of u will generate the Beta observed from the experiment?

# Model 1

In our most basic iteration, we can use the equation from before.

$$
\beta = f u 
$$

```{r, include=F}
m1_ll <- function(u){

  get_beta <- function(f, u){
    f*u
    }
    beta_summ$beta_pred <- get_beta(f = beta_summ$f, u = u)

    resid <- log(beta_summ$beta.est) - log(beta_summ$beta_pred)

      nll <- dnorm(resid,
                   mean = 0,
                   sd = sd(resid, na.rm = T),
                   log = T)
      -sum(nll, na.rm = T)
}
```

```{r, include=F}
start_time <- Sys.time()
m1_beta_fit <- mle2(m1_ll,
                skip.hessian = T,
                start=list(u = 1*10^-10),
                method = "L-BFGS-B",
                lower = c(0),
                upper = c(Inf),
                control=list(parscale=c(u = 1*10^-10), maxit=10000))
end_time <- Sys.time()
m1_runtime <- end_time-start_time
m1_runtime

coef(m1_beta_fit)
```


There should be another way to do this using all the data rather than just the summarized data. The objective function should rely on the number of infected per treatment which relies on beta which relies on u.

```{r}
fitness <- read.csv(here("raw_data/main_fitness_edit.csv")) #must be read.csv
fitness %<>% dplyr::select(tube, temp_id, REMOVED, KBP, final_date)
mort <-  read_csv(here("raw_data/main_mort_edit.csv"))

dataset <- left_join(mort,fitness)

```


This chunk removes individuals with NA for "inf". These ones we were unsure whether they were infected because they died too early to check for infection or went missing. 
```{r}
dataset %<>% filter(species == "D") %>% #only daphnia for this analysis
  filter(temp %in% const_temp) #only constant temp for this analysis

dataset %<>% mutate(birthdate = ifelse(species == "daphnia", "4/5/22", "4/6/22"), 
                    lifespan = as.numeric(mdy(final_date) - mdy(birthdate)),
                    temp = as.numeric(temp),
                    treatment = paste(temp, resource, sep = "_")) %>% 
  filter(is.na(male)) %>% #remove males
  filter(is.na(missing)) %>% #remove missing
  filter(!is.na(inf)) #remove NAs for inf for estimating beta. sometimes they died too young to tell
```

We can measure prevalence AKA probability of infection again because the last time it was done was with the unknown infected individuals included
```{r}
prob_inf <- dataset %>% group_by(temp, resource) %>% summarize(prob_inf = sum(inf)/n())
beta_summ %<>% left_join(., prob_inf)
```



```{r}
dataset %<>% mutate(inf_status = inf, dead = ifelse(is.na(REMOVED) & is.na(KBP), 1, 0))


```

```{r}
dataset %<>% mutate(f = get_f(dataset$temp, dataset$resource))
```

```{r}
dataset %<>% mutate(spore_exposure = 200, #spores/mL
                    uninf = 1-inf_status,
                    time = 1, #duration of exposure in days
                    trt = paste(temp, resource, species, sep = "_"))


# will loop through all treatments:
trts <- unique(dataset$treatment)

treatments <- unique(dataset$treatment) 
length(treatments) # how many unique? # this tells you how big to make the summary 

```
 
$$
probability\ of\ infection = e^{-f u  Zt}
$$
 
# Need to check units

```{r, eval=F}
m1_ll <- function(u){
  tmp <- dataset
  
    inf_out <- function(inf_status, f, u, spore_exposure, time){
    dbinom(x = inf_status, size = 1, prob=1-exp(-f*u*spore_exposure*time))
  }
  
  tmp %<>% 
    mutate(ll = mapply(inf_out, inf_status = inf_status, f = f, u = u, spore_exposure = spore_exposure, time = time))
  -sum(tmp$ll)
}
```


```{r, eval=F}
m1_u_fita <- mle2(m1_ll, start=list(u = 0.00001), 
                     control=list(parscale = c(u = 0.00001)),
                     skip.hessian=F, method="L-BFGS-B", lower=0, upper=1)
      #this produces a warning: NaNs produced - not sure if this is an issue
```

```{r}
m1_u_fit <- mle2(uninf ~ dbinom(size = 1, prob=exp(-f*u*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.0000001), 
                     control=list(parscale = c(u = 0.0000001)),
                     skip.hessian=F, method="L-BFGS-B", lower=0, upper=1)
```

Let's see if this is getting a decent estimate per treatment
```{r}
m1_fits <- beta_summ %>% dplyr::select(temp, resource)
for (i in 1:length(treatments)){
  dsub <- dataset %>% filter(treatment == treatments[i])
  m1_fits$treatment[i] <- treatments[i]
  m1_fits$u[i] <- coef(mle2(uninf ~ dbinom(size = 1, prob=exp(-f*u*spore_exposure*time)), 
                 data=dsub, start=list(u = 0.0000001), 
                 control=list(parscale = c(u = 0.0000001)),
                 skip.hessian=F, method="L-BFGS-B", lower=0, upper=1))[1]
}
```

```{r}
beta_summ %<>% left_join(., m1_fits)
```

```{r}
beta_summ %>% ggplot(.,aes(x=prev, y=1-exp(-f*u*z))) + geom_point()
```







# Model 2

Then we can try to incorporate temperature using an Arrhenius coefficient

$$
probability\ of\ infection = e^{-f u e^{T_{A}(1/T_{R}-1/T)} Zt}
$$

```{r, eval=F}
m2_ll <- function(u, arr_t){
  tmp <- dataset
  
    inf_out <- function(inf_status, f, u, arr_t, spore_exposure, time, temp){
    dbinom(x = inf_status, size = 1, prob=exp(-f*u*spore_exposure*time*exp(arr_t*(1/ref_t-1/temp))))
  }
  
  tmp %<>% 
    mutate(ll = mapply(inf_out, inf_status = inf, f = f, u = u, arr_t=arr_t, spore_exposure = spore_exposure, time = time, temp = temp))
  -sum(tmp$ll)
}
```



```{r, eval=F}
m2_u_fit <- mle2(m2_ll, start=list(u = 0.0001, arr_t = 100), 
                     control=list(parscale = c(u = 0.0001, arr_t = 100)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0), upper=c(u = 1, arr_t = Inf))

```

```{r}
m2_u_fit <- mle2(uninf ~ dbinom(size = 1, prob=exp(-f*u*spore_exposure*time*exp(arr_t*(1/ref_t-1/temp)))), 
                 data=dataset, start=list(u = 0.0001, arr_t = 100), 
                     control=list(parscale = c(u = 0.0001, arr_t = 100)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0), upper=c(u = 1, arr_t = Inf))
```


```{r}
m2_fits <- beta_summ %>% dplyr::select(temp, resource)
for (i in 1:length(treatments)){
  dsub <- dataset %>% filter(treatment == treatments[i])
  m2_fits$treatment[i] <- treatments[i]
  model <- mle2(uninf ~ dbinom(size = 1, prob=exp(-f*u*spore_exposure*time*exp(arr_t*(1/ref_t-1/temp)))), 
                 data=dsub, start=list(u = 0.00001, arr_t = 10), 
                     control=list(parscale = c(u = 0.00001, arr_t = 10)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0), upper=c(u = 1, arr_t = Inf))
  m2_fits$m2_u[i] <- coef(model)[1]
  m2_fits$m2_arr[i] <- coef(model)[2]
  
}
```

```{r}
beta_summ %<>% left_join(., m2_fits)
```

```{r}
beta_summ %>% ggplot(.,aes(x=prev, y=1-exp(-f*m2_u*z*exp(m2_arr*(1/ref_t-1/temp))))) + geom_point()
```


# Model 3

And try to incorporate resource using a half-saturation constant

$$
probability\ of\ infection = e^{-f(\frac{uR}{k + R})Zt}
$$

```{r, eval=F}
m3_ll <- function(u, k){
  tmp <- dataset
  
    inf_out <- function(inf_status, f, u, k, spore_exposure, time, resource){
    dbinom(x = inf_status, size = 1, prob = exp(-f*(u*resource/(k + resource))*spore_exposure*time))
  }
  
  tmp %<>% 
    mutate(ll = mapply(inf_out, inf_status = inf, f = f, u = u, k=k, spore_exposure = spore_exposure, time = time, resource = resource))
  -sum(tmp$ll)
}
```



```{r, eval=F}
m3_u_fit <- mle2(m3_ll, start=list(u = 0.01, k = 1), 
                     control=list(parscale = c(u = 0.01, k = 1)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, k = 0), upper=c(u = 1, k = Inf))
```

```{r}
m3_u_fit <- mle2(uninf ~ dbinom(size = 1, prob = exp(-f*(u*resource/(k + resource))*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.0001, k = 1), 
                     control=list(parscale = c(u = 0.0001, k = 1)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, k = 0), upper=c(u = 1, k = Inf))
```


# Model 4

And we can combine this to incorporate both temperature and resource-dependence


$$
probability\ of\ infection = e^{-f(\frac{u e^{T_{A}(1/T_{R}-1/T)} R}{k + R})Zt}
$$


```{r, eval=F}
m4_ll <- function(u, arr_t, k){
  tmp <- dataset
  
    inf_out <- function(inf_status, f, u, arr_t, k, spore_exposure, time, temp, resource){
    dbinom(x = inf_status, size = 1, prob = exp(-f*(u*exp(arr_t*(1/ref_t-1/temp))*resource/(k + resource))*spore_exposure*time))
  }
  
  tmp %<>% 
    mutate(ll = mapply(inf_out, inf_status = inf, f = f, u = u, arr_t=arr_t, k=k, spore_exposure = spore_exposure, time = time, temp=temp, resource = resource))
  -sum(tmp$ll)
}
```



```{r, eval=F}
m4_u_fit <- mle2(m4_ll, start=list(u = 0.001, arr_t = 10, k = 1), 
                     control=list(parscale = c(u = 0.001, arr_t = 10, k = 1)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0, k = 0), upper=c(u = 1, arr_t = Inf, k = Inf))
```

```{r}
m4_u_fit <- mle2(uninf ~ dbinom(size = 1, prob = exp(-f*(u*exp(arr_t*(1/ref_t-1/temp))*resource/
                                                           (k + resource))*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.001, arr_t = 10, k = 1), 
                     control=list(parscale = c(u = 0.001, arr_t = 10, k = 1)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0, k = 0), upper=c(u = 1, arr_t = Inf, k = Inf))
```

```{r}
mod_list <- list(m1_u_fit, m2_u_fit, m3_u_fit, m4_u_fit)
AICtab(mod_list, logLik=T, base=T, weights=T)
```


```{r}

beta_summ %<>% mutate(u_m1 = coef(m1_u_fit)[1],
                      beta_m1 = f*coef(m1_u_fit)[1],
                      u_m2 = coef(m2_u_fit)[1]*exp(coef(m2_u_fit)[2]*(1/ref_t-1/temp)),
                      beta_m2 = f*u_m2,
                      u_m3 = (coef(m3_u_fit)[1]*resource/(coef(m3_u_fit)[2] + resource)),
                      beta_m3 = f*u_m3,
                      u_m4 = (coef(m4_u_fit)[1]*exp(coef(m4_u_fit)[2]*(1/ref_t-1/temp))*resource/(coef(m4_u_fit)[3] + resource)),
                      beta_m4 = f*u_m4)

beta_summ %>% ggplot(.,aes(x=beta_m1, y=beta_m2)) + geom_point()
beta_summ %>% ggplot(.,aes(x=beta_m3, y=beta_m4)) + geom_point()


ggplot(beta_summ,aes(x=prev, y=beta_m4)) + geom_point() #this won't look linear because foraging rate changes
ggplot(beta_summ,aes(x=prev, y=beta.est)) + geom_point() #this should still look linear

```

But can we get u to match up?

```{r}
ggplot(beta_summ,aes(x=prev, y=1-exp(-f*u_m1*z))) + geom_point() 
ggplot(beta_summ,aes(x=prev, y=1-exp(-beta_m2*z))) + geom_point() 
ggplot(beta_summ,aes(x=prev, y=1-exp(-beta_m3*z))) + geom_point() 
ggplot(beta_summ,aes(x=prev, y=1-exp(-beta_m4*z))) + geom_point() 
```


```{r}
beta_summ %>% ggplot(.,aes(x=resource, y=u_m4*f, group=temp, color=as.factor(temp))) + geom_point()
```
From Alex's script for constant f and constant u
```{r}
#1 - exp((cfcu$u[i])*z.seq*vol*(exp(-(cfcu$f.0.hat[i]/vol)*(cfcu$length[i]^2)*cfcu$time[i])-1))
```



I don't think this is right
```{r}
beta_summ %<>% mutate(m1_prev = beta_m1*z,
                      m2_prev = beta_m2*z,
                      m3_prev = beta_m3*z,
                      m4_prev = beta_m4*z)
```

```{r}
beta_summ %>% ggplot(.,aes(x=m1_prev, y=prev)) + geom_point()
beta_summ %>% ggplot(.,aes(x=m2_prev, y=prev)) + geom_point()
beta_summ %>% ggplot(.,aes(x=m3_prev, y=prev)) + geom_point()
beta_summ %>% ggplot(.,aes(x=m4_prev, y=prev)) + geom_point()
```

Not great but maybe because these aren't great fits?



```{r}
test <- tibble(resource = seq(0,1,length.out=11),
               temp = seq(15,25,length.out=11))
test %<>% mutate(f = get_f(test$temp, test$resource))
```


```{r}
u <- 1
arr_t <- 25
k <- 1500
p <- -30
test %<>% mutate(m5a = exp(-f*(u*exp((arr_t+p*resource)*(1/ref_t-1/temp))*resource/(k + resource))*z*1))
```




# Models 5-7

Finally, we can also include interactions for our temperature and resource-dependent parameters so that they can interact with each other...

$$
probability\ of\ infection = e^{-f(\frac{u e^{T_{A}(1/T_{R}-1/T)} R}{k + R})Zt}
$$

linearly...
$$
T_{A} = {T_{A}}' + {\rho}R \\
$$
```{r}
m5a_u_fit <- mle2(uninf ~ dbinom(size = 1, prob = 
                                   exp(-f*((u*exp((arr_t+p*resource)*(1/ref_t-1/temp))*resource)/
                                             (k + resource))*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.001, arr_t = 1, k = 10, p=1), 
                     control=list(parscale = c(u = 0.001, arr_t = 1, k = 10, p=1)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0, k = 0, p=-Inf), upper=c(u = 1, arr_t = Inf, k = Inf, p=Inf))
```

$$
T_{A} = {T_{A}}'e^{{\rho}R}
$$

```{r}
m5b_u_fit <- mle2(uninf ~ dbinom(size = 1, prob = 
                                   exp(-f*(u*exp((arr_t*exp(p*resource))*(1/ref_t-1/temp))*resource/
                                             (k + resource))*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.001, arr_t = 10, k = 1, p=0.1), 
                     control=list(parscale = c(u = 0.001, arr_t = 10, k = 1, p=0.1)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0, k = 0, p=-Inf), upper=c(u = 1, arr_t = Inf, k = Inf, p=Inf))
```


$$
k = k' + {\omega}T
$$
```{r}
m6a_u_fit <- mle2(uninf ~ dbinom(size = 1, prob = exp(-f*(u*exp(arr_t*(1/ref_t-1/temp))*resource/((k + w*temp) + resource))*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.001, arr_t = 10, k = 1, w=0.01), 
                     control=list(parscale = c(u = 0.001, arr_t = 10, k = 1, w=0.01)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0, k = 0, w=-Inf), upper=c(u = 1, arr_t = Inf, k = Inf, w=Inf))

```



$$
k = k'e^{{\omega}T}
$$

```{r}
m6b_u_fit <- mle2(uninf ~ dbinom(size = 1, prob = exp(-f*(u*exp(arr_t*(1/ref_t-1/temp))*resource/((k*exp(w*temp)) + resource))*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.001, arr_t = 10, k = 1, w=1), 
                     control=list(parscale = c(u = 0.001, arr_t = 10, k = 1, w=1)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0, k = 0, w=-Inf), upper=c(u = 1, arr_t = Inf, k = Inf, w=Inf))

```


```{r}
m7a_u_fit <- mle2(uninf ~ dbinom(size = 1, prob = exp(-f*(u*exp((arr_t+p*resource)*(1/ref_t-1/temp))*resource/((k + w*temp) + resource))*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.0001, arr_t = 10, k = 1, p=0.1, w=0.01), 
                     control=list(parscale = c(u = 0.0001, arr_t = 10, k = 1, p=0.1, w=0.01)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0, k = 0, p=-Inf, w=-Inf), upper=c(u = 1, arr_t = Inf, k = Inf, p=Inf, w=Inf))
```

```{r}
m7b_u_fit <- mle2(uninf ~ dbinom(size = 1, prob = exp(-f*(u*exp((arr_t*exp(p*resource))*(1/ref_t-1/temp))*resource/((k*exp(w*temp)) + resource))*spore_exposure*time)), 
                 data=dataset, start=list(u = 0.001, arr_t = 10, k = 1, p=0.1, w=0.1), 
                     control=list(parscale = c(u = 0.001, arr_t = 10, k = 1, p=0.1, w=0.1)),
                     skip.hessian=F, method="L-BFGS-B", 
                 lower=c(u = 0, arr_t = 0, k = 0, p=-Inf, w=-Inf), upper=c(u = 1, arr_t = Inf, k = Inf, p=Inf, w=Inf))
```

```{r}
mod_list <- list(m1_u_fit, m2_u_fit, m3_u_fit, m4_u_fit,
                 m5a_u_fit, m5b_u_fit, m6a_u_fit, m6b_u_fit,
                 m7a_u_fit, m7b_u_fit)

mod_names <- c("m1", "m2", "m3", "m4", 
               "m5a", "m5b", "m6a", "m6b", 
               "m7a", "m7b")
mod_names_descriptive <- c("size", "temp", "rsc", "full", 
                           "arr(R)~LIN", "arr(R)~EXP", "h(T)~LIN", "h(T)~EXP", 
                           "LIN-LIN", "EXP_EXP")
mod_names_full <- paste(mod_names, mod_names_descriptive, sep="_")

AICtab(mod_list, logLik=T, base=T, mnames=mod_names_full, weights=T)
```


```{r}
beta_summ %<>% mutate(u_m5a = (coef(m5a_u_fit)[1]*exp((coef(m5a_u_fit)[2]+coef(m5a_u_fit)[4]+resource))*(1/ref_t-1/temp))*resource/(coef(m5a_u_fit)[3] + resource),
                      beta_m5a = f*u_m5a,
                      m5a_prev = beta_m5a*z,
                      u_m5b = (coef(m5b_u_fit)[1]*exp((coef(m5b_u_fit)[2]*exp(coef(m5b_u_fit)[4]+resource)))*(1/ref_t-1/temp))*resource/(coef(m5b_u_fit)[3] + resource),
                      beta_m5b = f*u_m5b,
                      m5b_prev = beta_m5b*z)
```

```{r}
beta_summ %>% ggplot(.,aes(x=prev, y=1-exp(-beta_m5b*z))) + geom_point()
```


